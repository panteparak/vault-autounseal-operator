name: Integration Tests

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  schedule:
    - cron: '0 4 * * 1'  # Weekly on Monday at 4 AM UTC

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  GO_VERSION: '1.21'

jobs:
  k3d-integration-test:
    name: K3d Integration Test
    runs-on: ubuntu-latest
    timeout-minutes: 25

    strategy:
      fail-fast: false
      matrix:
        vault-version: ['1.20.0']
        test-scenario: ['basic', 'failover', 'multi-vault']

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Go
      uses: actions/setup-go@v5
      with:
        go-version: ${{ env.GO_VERSION }}

    - name: Install dependencies
      run: |
        go mod download

        # Install k3d
        curl -s https://raw.githubusercontent.com/k3d-io/k3d/main/install.sh | bash

        # Install kubectl
        curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
        chmod +x kubectl
        sudo mv kubectl /usr/local/bin/

        # Install Helm
        curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash

    - name: Build operator image
      run: |
        echo "ðŸ”¨ Building operator image..."
        docker build \
          --target production \
          --build-arg VERSION=test \
          --build-arg BUILD_TIME="$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
          --build-arg GIT_COMMIT="${GITHUB_SHA}" \
          -t vault-autounseal-operator:test .

        echo "ðŸ” Verifying built image..."
        docker run --rm --entrypoint="" vault-autounseal-operator:test ls -la / || echo "File listing failed"
        docker run --rm --entrypoint="" vault-autounseal-operator:test ls -la /manager || echo "Manager binary check failed"
        docker run --rm --entrypoint="" vault-autounseal-operator:test /manager --version || echo "Version check failed"
        docker run --rm --entrypoint="" vault-autounseal-operator:test /manager --help || echo "Help check failed"

    - name: Start K3d cluster
      run: |
        echo "ðŸš€ Starting K3d cluster with 1 node..."

        # Create k3d cluster with single node
        k3d cluster create vault-test --wait --timeout 300s

        # Import operator image into cluster
        k3d image import vault-autounseal-operator:test -c vault-test

        # Verify cluster
        kubectl get nodes
        echo "âœ… K3d cluster ready with 1 node"

    - name: Start Vault instance(s)
      env:
        VAULT_VERSION: ${{ matrix.vault-version }}
        TEST_SCENARIO: ${{ matrix.test-scenario }}
      run: |
        echo "ðŸ›ï¸ Starting Vault $VAULT_VERSION for scenario: $TEST_SCENARIO"

        case "$TEST_SCENARIO" in
          "basic")
            echo "ðŸ›ï¸ Setting up Basic scenario: Single Vault instance in dev mode"
            docker run -d --name vault-primary --cap-add=IPC_LOCK -p 8200:8200 \
              -e VAULT_DEV_ROOT_TOKEN_ID=root \
              -e VAULT_DEV_LISTEN_ADDRESS=0.0.0.0:8200 \
              hashicorp/vault:$VAULT_VERSION

            # Wait for Vault
            echo "â³ Waiting for Vault to be ready..."
            timeout=60
            while [ $timeout -gt 0 ]; do
              if curl -s http://localhost:8200/v1/sys/health > /dev/null 2>&1; then
                echo "âœ… Basic Vault instance ready at http://localhost:8200"
                break
              fi
              sleep 2
              timeout=$((timeout - 2))
            done
            [ $timeout -le 0 ] && { echo "âŒ Timeout waiting for basic Vault"; exit 1; }
            ;;

          "failover")
            echo "ðŸ”„ Setting up Failover scenario: Primary + Standby Vault instances"
            # Start primary Vault in dev mode
            docker run -d --name vault-primary --cap-add=IPC_LOCK -p 8200:8200 \
              -e VAULT_DEV_ROOT_TOKEN_ID=root \
              -e VAULT_DEV_LISTEN_ADDRESS=0.0.0.0:8200 \
              hashicorp/vault:$VAULT_VERSION

            # Start standby Vault (will be used for failover testing)
            docker run -d --name vault-standby --cap-add=IPC_LOCK -p 8201:8200 \
              -e VAULT_DEV_ROOT_TOKEN_ID=standby-token \
              -e VAULT_DEV_LISTEN_ADDRESS=0.0.0.0:8200 \
              hashicorp/vault:$VAULT_VERSION

            # Wait for both instances
            for port_name in "8200:Primary" "8201:Standby"; do
              port=$(echo $port_name | cut -d: -f1)
              name=$(echo $port_name | cut -d: -f2)
              echo "â³ Waiting for $name Vault on port $port..."
              timeout=60
              while [ $timeout -gt 0 ]; do
                if curl -s http://localhost:$port/v1/sys/health > /dev/null 2>&1; then
                  echo "âœ… $name Vault ready on port $port"
                  break
                fi
                sleep 2
                timeout=$((timeout - 2))
              done
              [ $timeout -le 0 ] && { echo "âŒ Timeout waiting for $name Vault"; exit 1; }
            done
            ;;

          "multi-vault")
            echo "ðŸ—ï¸ Setting up Multi-vault scenario: Multiple independent Vault clusters"
            # Start Vault cluster 1 (Finance)
            docker run -d --name vault-finance --cap-add=IPC_LOCK -p 8200:8200 \
              -e VAULT_DEV_ROOT_TOKEN_ID=finance-root \
              -e VAULT_DEV_LISTEN_ADDRESS=0.0.0.0:8200 \
              hashicorp/vault:$VAULT_VERSION

            # Start Vault cluster 2 (Engineering)
            docker run -d --name vault-engineering --cap-add=IPC_LOCK -p 8201:8200 \
              -e VAULT_DEV_ROOT_TOKEN_ID=eng-root \
              -e VAULT_DEV_LISTEN_ADDRESS=0.0.0.0:8200 \
              hashicorp/vault:$VAULT_VERSION

            # Start Vault cluster 3 (Operations)
            docker run -d --name vault-operations --cap-add=IPC_LOCK -p 8202:8200 \
              -e VAULT_DEV_ROOT_TOKEN_ID=ops-root \
              -e VAULT_DEV_LISTEN_ADDRESS=0.0.0.0:8200 \
              hashicorp/vault:$VAULT_VERSION

            # Wait for all three instances
            for port_name in "8200:Finance" "8201:Engineering" "8202:Operations"; do
              port=$(echo $port_name | cut -d: -f1)
              cluster=$(echo $port_name | cut -d: -f2)
              echo "â³ Waiting for $cluster Vault cluster on port $port..."
              timeout=60
              while [ $timeout -gt 0 ]; do
                if curl -s http://localhost:$port/v1/sys/health > /dev/null 2>&1; then
                  echo "âœ… $cluster Vault cluster ready on port $port"
                  break
                fi
                sleep 2
                timeout=$((timeout - 2))
              done
              [ $timeout -le 0 ] && { echo "âŒ Timeout waiting for $cluster Vault"; exit 1; }
            done
            ;;

          *)
            echo "âŒ Unknown test scenario: $TEST_SCENARIO"
            exit 1
            ;;
        esac

    - name: Deploy operator with Helm
      env:
        TEST_SCENARIO: ${{ matrix.test-scenario }}
        VAULT_VERSION: ${{ matrix.vault-version }}
      run: |
        echo "ðŸ”§ Deploying vault-autounseal-operator using Helm for scenario: $TEST_SCENARIO"
        kubectl get crd vaultunsealconfigs.vault.io || true
        # Create namespace (ignore if exists)
        kubectl create namespace vault-operator-system || true
        # Clean up any existing CRDs to prevent conflicts
        kubectl delete crd vaultunsealconfigs.vault.io --ignore-not-found=true

        # Create test configuration values
        cat > /tmp/test-values.yaml <<EOF
        image:
          repository: vault-autounseal-operator
          tag: test
          pullPolicy: Never

        operator:
          logLevel: debug

        resources:
          requests:
            cpu: 100m
            memory: 128Mi
          limits:
            cpu: 500m
            memory: 256Mi

        crd:
          create: true
        EOF

        # Create vault configuration secret (delete and recreate if exists)
        kubectl delete secret vault-config --namespace=vault-operator-system --ignore-not-found=true

        case "$TEST_SCENARIO" in
          "basic")
            echo "ðŸ“ Creating config for Basic scenario (single Vault)"
            kubectl create secret generic vault-config \
              --namespace=vault-operator-system \
              --from-literal=vault-endpoints="http://host.docker.internal:8200"
            ;;
          "failover")
            echo "ðŸ“ Creating config for Failover scenario (primary + standby)"
            kubectl create secret generic vault-config \
              --namespace=vault-operator-system \
              --from-literal=vault-endpoints="http://host.docker.internal:8200,http://host.docker.internal:8201"
            ;;
          "multi-vault")
            echo "ðŸ“ Creating config for Multi-vault scenario (3 clusters)"
            kubectl create secret generic vault-config \
              --namespace=vault-operator-system \
              --from-literal=vault-endpoints="http://host.docker.internal:8200,http://host.docker.internal:8201,http://host.docker.internal:8202"
            ;;
        esac

        # Deploy using Helm with upgrade --install to handle existing installations
        echo "ðŸš€ Deploying with Helm (increased timeout for pod startup)..."
        helm upgrade --install vault-autounseal-operator ./helm/vault-autounseal-operator \
          --namespace vault-operator-system \
          --values /tmp/test-values.yaml \
          --wait --timeout=600s \
          --debug || {
            echo "âŒ Helm deployment failed, gathering debug info..."
            kubectl get pods -n vault-operator-system -o wide
            kubectl describe pods -l app.kubernetes.io/name=vault-autounseal-operator -n vault-operator-system
            kubectl logs -l app.kubernetes.io/name=vault-autounseal-operator -n vault-operator-system --tail=50 || true
            kubectl get events -n vault-operator-system --sort-by='.lastTimestamp' --field-selector type=Warning
            exit 1
          }

        echo "âœ… Operator deployed successfully via Helm"

    - name: Run comprehensive integration tests
      run: |
        echo "ðŸ§ª Running comprehensive integration tests for Vault ${{ matrix.vault-version }}"

        # Wait for operator pods to be ready
        echo "â³ Waiting for operator to be ready..."
        kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=vault-autounseal-operator -n vault-operator-system --timeout=300s

        # Test 1: Verify operator is running and healthy
        echo "ðŸ“‹ Test 1: Operator Health Check"
        kubectl get pods -n vault-operator-system -o wide
        kubectl logs -l app.kubernetes.io/name=vault-autounseal-operator -n vault-operator-system --tail=20

        # Test 2: Check initial Vault status (should be sealed in dev mode)
        echo "ðŸ›ï¸ Test 2: Initial Vault Status Check"
        VAULT_STATUS=$(curl -s http://localhost:8200/v1/sys/seal-status || echo "failed")
        echo "Vault status: $VAULT_STATUS"

        # Test 3: Create VaultUnsealConfig CRD resource
        echo "ðŸ“ Test 3: Creating VaultUnsealConfig Resource for $TEST_SCENARIO scenario"

        case "$TEST_SCENARIO" in
          "basic")
            cat <<EOF | kubectl apply -f -
        apiVersion: vault.io/v1
        kind: VaultUnsealConfig
        metadata:
          name: test-basic-vault-config
          namespace: default
        spec:
          vaultInstances:
          - name: vault-basic
            endpoint: "http://host.docker.internal:8200"
            unsealKeys:
            - "$(echo -n 'basic-key-1' | base64)"
            - "$(echo -n 'basic-key-2' | base64)"
            - "$(echo -n 'basic-key-3' | base64)"
            threshold: 3
            tlsSkipVerify: true
        EOF
            ;;

          "failover")
            cat <<EOF | kubectl apply -f -
        apiVersion: vault.io/v1
        kind: VaultUnsealConfig
        metadata:
          name: test-failover-vault-config
          namespace: default
        spec:
          vaultInstances:
          - name: vault-primary
            endpoint: "http://host.docker.internal:8200"
            unsealKeys:
            - "$(echo -n 'failover-primary-key-1' | base64)"
            - "$(echo -n 'failover-primary-key-2' | base64)"
            - "$(echo -n 'failover-primary-key-3' | base64)"
            threshold: 3
            tlsSkipVerify: true
          - name: vault-standby
            endpoint: "http://host.docker.internal:8201"
            unsealKeys:
            - "$(echo -n 'failover-standby-key-1' | base64)"
            - "$(echo -n 'failover-standby-key-2' | base64)"
            - "$(echo -n 'failover-standby-key-3' | base64)"
            threshold: 3
            tlsSkipVerify: true
        EOF
            ;;

          "multi-vault")
            cat <<EOF | kubectl apply -f -
        apiVersion: vault.io/v1
        kind: VaultUnsealConfig
        metadata:
          name: test-multi-vault-config
          namespace: default
        spec:
          vaultInstances:
          - name: vault-finance
            endpoint: "http://host.docker.internal:8200"
            unsealKeys:
            - "$(echo -n 'finance-key-1' | base64)"
            - "$(echo -n 'finance-key-2' | base64)"
            - "$(echo -n 'finance-key-3' | base64)"
            threshold: 3
            tlsSkipVerify: true
          - name: vault-engineering
            endpoint: "http://host.docker.internal:8201"
            unsealKeys:
            - "$(echo -n 'engineering-key-1' | base64)"
            - "$(echo -n 'engineering-key-2' | base64)"
            - "$(echo -n 'engineering-key-3' | base64)"
            threshold: 3
            tlsSkipVerify: true
          - name: vault-operations
            endpoint: "http://host.docker.internal:8202"
            unsealKeys:
            - "$(echo -n 'operations-key-1' | base64)"
            - "$(echo -n 'operations-key-2' | base64)"
            - "$(echo -n 'operations-key-3' | base64)"
            threshold: 3
            tlsSkipVerify: true
        EOF
            ;;
        esac

        echo "âœ… VaultUnsealConfig resource created"

        # Test 4: Verify CRD resource was created
        echo "ðŸ” Test 4: Verify CRD Resource"
        kubectl get vaultunsealconfigs -o wide
        kubectl describe vaultunsealconfigs

        # Test 5: Wait for operator to process the resource
        echo "â³ Test 5: Waiting for operator to process resource..."
        sleep 30

        # Test 6: Check operator logs for processing
        echo "ðŸ“ Test 6: Operator Processing Logs"
        kubectl logs -l app.kubernetes.io/name=vault-autounseal-operator -n vault-operator-system --tail=50

        # Test 7: Verify VaultUnsealConfig status is updated
        echo "ðŸ“Š Test 7: Check Resource Status Updates"
        kubectl get vaultunsealconfigs -o yaml

        # Test 8: Test Vault unsealing (note: dev mode Vault doesn't seal/unseal like production)
        echo "ðŸ”“ Test 8: Vault Accessibility Test for $TEST_SCENARIO scenario"

        case "$TEST_SCENARIO" in
          "basic")
            echo "ðŸ§ª Testing single basic Vault instance..."
            curl -s http://localhost:8200/v1/sys/health | jq '.initialized // false' || echo "Basic Vault test failed"
            ;;

          "failover")
            echo "ðŸ§ª Testing primary and standby Vault instances..."
            curl -s http://localhost:8200/v1/sys/health | jq '.initialized // false' || echo "Primary Vault test failed"
            curl -s http://localhost:8201/v1/sys/health | jq '.initialized // false' || echo "Standby Vault test failed"
            ;;

          "multi-vault")
            echo "ðŸ§ª Testing all three Vault clusters..."
            curl -s http://localhost:8200/v1/sys/health | jq '.initialized // false' || echo "Finance Vault test failed"
            curl -s http://localhost:8201/v1/sys/health | jq '.initialized // false' || echo "Engineering Vault test failed"
            curl -s http://localhost:8202/v1/sys/health | jq '.initialized // false' || echo "Operations Vault test failed"
            ;;
        esac

        # Test 9: Check for any error events
        echo "âš ï¸ Test 9: Check for Error Events"
        kubectl get events --field-selector type=Warning -o wide

        # Test 10: Final operator health check
        echo "ðŸ’š Test 10: Final Health Verification"
        kubectl get pods -n vault-operator-system
        kubectl get vaultunsealconfigs -o wide

        echo "âœ… Integration tests completed successfully!"

    - name: Test resource cleanup and recreation
      run: |
        echo "ðŸ§¹ Testing resource lifecycle management..."

        # Delete the VaultUnsealConfig
        kubectl delete vaultunsealconfigs --all

        # Wait for cleanup
        sleep 10

        # Verify cleanup in logs
        kubectl logs -l app.kubernetes.io/name=vault-autounseal-operator -n vault-operator-system --tail=20

        # Recreate resource to test operator resilience
        cat <<EOF | kubectl apply -f -
        apiVersion: vault.io/v1
        kind: VaultUnsealConfig
        metadata:
          name: test-resilience-config
          namespace: default
        spec:
          vaultInstances:
          - name: vault-test
            endpoint: "http://host.docker.internal:8200"
            unsealKeys:
            - "$(echo -n 'test-resilience-key' | base64)"
            threshold: 1
            tlsSkipVerify: true
        EOF

        # Wait and verify
        sleep 15
        kubectl get vaultunsealconfigs -o wide
        kubectl logs -l app.kubernetes.io/name=vault-autounseal-operator -n vault-operator-system --tail=10

        echo "âœ… Resource lifecycle tests completed!"

    - name: Test with production-like Vault (sealed state)
      run: |
        echo "ðŸ­ Testing with production-like sealed Vault..."

        # Stop dev mode Vault
        docker stop vault-primary || true

        # Start Vault in production mode (sealed by default)
        docker run -d --name vault-prod --cap-add=IPC_LOCK -p 8202:8200 \
          -e VAULT_API_ADDR=http://0.0.0.0:8200 \
          hashicorp/vault:${{ matrix.vault-version }} server -dev=false -config=/tmp/vault.hcl || {
          # If that fails, use a simpler production config
          docker run -d --name vault-prod --cap-add=IPC_LOCK -p 8202:8200 \
            hashicorp/vault:${{ matrix.vault-version }} server -dev=false
        }

        # Wait for Vault to start
        sleep 10

        # Check sealed status
        echo "ðŸ”’ Checking sealed Vault status..."
        curl -s http://localhost:8202/v1/sys/seal-status | jq '.' || echo "Sealed Vault not accessible yet"

        # Create VaultUnsealConfig for production Vault
        cat <<EOF | kubectl apply -f -
        apiVersion: vault.io/v1
        kind: VaultUnsealConfig
        metadata:
          name: test-prod-vault-config
          namespace: default
        spec:
          vaultInstances:
          - name: vault-production
            endpoint: "http://host.docker.internal:8202"
            unsealKeys:
            - "$(echo -n 'prod-key-1' | base64)"
            - "$(echo -n 'prod-key-2' | base64)"
            - "$(echo -n 'prod-key-3' | base64)"
            threshold: 3
            tlsSkipVerify: true
        EOF

        # Wait for operator to attempt unsealing
        echo "â³ Waiting for operator to process production Vault..."
        sleep 20

        # Check operator logs for unsealing attempts
        echo "ðŸ“ Operator logs for production Vault processing:"
        kubectl logs -l app.kubernetes.io/name=vault-autounseal-operator -n vault-operator-system --tail=30

        # Check resource status
        kubectl get vaultunsealconfigs test-prod-vault-config -o yaml | grep -A 10 status: || echo "No status found"

        # Clean up production Vault
        docker stop vault-prod || true
        docker rm vault-prod || true

        echo "âœ… Production Vault testing completed!"

    - name: Cleanup
      if: always()
      run: |
        # Uninstall Helm chart
        helm uninstall vault-autounseal-operator -n vault-operator-system || true

        # Delete k3d cluster
        k3d cluster delete vault-test || true

        # Stop all Vault containers
        docker rm -f vault-primary vault-standby vault-secondary vault-finance vault-engineering vault-operations vault-prod || true

  helm-chart-tests:
    name: Helm Chart Tests
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Install Helm
      run: |
        curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash

    - name: Lint Helm chart
      run: |
        echo "ðŸ” Linting Helm chart..."
        helm lint ./helm/vault-autounseal-operator

    - name: Template Helm chart
      run: |
        echo "ðŸ“ Templating Helm chart..."
        helm template vault-autounseal-operator ./helm/vault-autounseal-operator > /tmp/template.yaml

    - name: Package Helm chart
      run: |
        echo "ðŸ“¦ Packaging Helm chart..."
        helm package ./helm/vault-autounseal-operator --destination /tmp/
