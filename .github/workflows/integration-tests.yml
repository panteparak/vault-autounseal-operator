name: Integration Tests

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  schedule:
    - cron: '0 4 * * 1'  # Weekly on Monday at 4 AM UTC

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  GO_VERSION: '1.21'

jobs:
  k3d-integration-test:
    name: K3d Integration Test
    runs-on: ubuntu-latest
    timeout-minutes: 25

    strategy:
      fail-fast: false
      matrix:
        vault-version: ['1.20.0']
        test-scenario: ['basic', 'failover', 'multi-vault']

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Go
      uses: actions/setup-go@v5
      with:
        go-version: ${{ env.GO_VERSION }}

    - name: Install dependencies
      run: |
        go mod download

        # Install k3d
        curl -s https://raw.githubusercontent.com/k3d-io/k3d/main/install.sh | bash

        # Install kubectl
        curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
        chmod +x kubectl
        sudo mv kubectl /usr/local/bin/

        # Install Helm
        curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash

    - name: Build operator image
      run: |
        echo "🔨 Building operator image..."
        docker build \
          --target production \
          --build-arg VERSION=test \
          --build-arg BUILD_TIME="$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
          --build-arg GIT_COMMIT="${GITHUB_SHA}" \
          -t vault-autounseal-operator:test .
        
        echo "🔍 Verifying built image..."
        docker run --rm --entrypoint="" vault-autounseal-operator:test ls -la / || echo "File listing failed"
        docker run --rm --entrypoint="" vault-autounseal-operator:test ls -la /manager || echo "Manager binary check failed"
        docker run --rm vault-autounseal-operator:test --version || echo "Version check failed"
        docker run --rm vault-autounseal-operator:test --help || echo "Help check failed"

    - name: Start K3d cluster
      run: |
        echo "🚀 Starting K3d cluster with 1 node..."

        # Create k3d cluster with single node
        k3d cluster create vault-test --wait --timeout 300s

        # Import operator image into cluster
        k3d image import vault-autounseal-operator:test -c vault-test

        # Verify cluster
        kubectl get nodes
        echo "✅ K3d cluster ready with 1 node"

    - name: Start Vault instance(s)
      env:
        VAULT_VERSION: ${{ matrix.vault-version }}
        TEST_SCENARIO: ${{ matrix.test-scenario }}
      run: |
        echo "🏛️ Starting Vault $VAULT_VERSION for scenario: $TEST_SCENARIO"

        if [ "$TEST_SCENARIO" = "multi-vault" ]; then
          echo "Starting multiple Vault instances..."

          # Start primary Vault
          docker run -d --name vault-primary --cap-add=IPC_LOCK -p 8200:8200 \
            -e VAULT_DEV_ROOT_TOKEN_ID=root -e VAULT_DEV_LISTEN_ADDRESS=0.0.0.0:8200 \
            hashicorp/vault:$VAULT_VERSION

          # Start secondary Vault
          docker run -d --name vault-secondary --cap-add=IPC_LOCK -p 8201:8200 \
            -e VAULT_DEV_ROOT_TOKEN_ID=root -e VAULT_DEV_LISTEN_ADDRESS=0.0.0.0:8200 \
            hashicorp/vault:$VAULT_VERSION

          # Wait for both instances
          for port in 8200 8201; do
            echo "Waiting for Vault on port $port..."
            timeout=60
            while [ $timeout -gt 0 ]; do
              if curl -s http://localhost:$port/v1/sys/health > /dev/null 2>&1; then
                echo "✅ Vault on port $port is ready"
                break
              fi
              sleep 2
              timeout=$((timeout - 2))
            done
            if [ $timeout -le 0 ]; then
              echo "❌ Timeout waiting for Vault on port $port"
              exit 1
            fi
          done
        else
          echo "Starting single Vault instance..."

          docker run -d --name vault-primary --cap-add=IPC_LOCK -p 8200:8200 \
            -e VAULT_DEV_ROOT_TOKEN_ID=root -e VAULT_DEV_LISTEN_ADDRESS=0.0.0.0:8200 \
            hashicorp/vault:$VAULT_VERSION

          # Wait for Vault
          echo "Waiting for Vault..."
          timeout=60
          while [ $timeout -gt 0 ]; do
            if curl -s http://localhost:8200/v1/sys/health > /dev/null 2>&1; then
              echo "✅ Vault is ready at http://localhost:8200"
              break
            fi
            sleep 2
            timeout=$((timeout - 2))
          done
          if [ $timeout -le 0 ]; then
            echo "❌ Timeout waiting for Vault"
            exit 1
          fi
        fi

    - name: Deploy operator with Helm
      env:
        TEST_SCENARIO: ${{ matrix.test-scenario }}
        VAULT_VERSION: ${{ matrix.vault-version }}
      run: |
        echo "🔧 Deploying vault-autounseal-operator using Helm for scenario: $TEST_SCENARIO"
        kubectl get crd vaultunsealconfigs.vault.io || true
        # Create namespace (ignore if exists)
        kubectl create namespace vault-operator-system || true
        # Clean up any existing CRDs to prevent conflicts
        kubectl delete crd vaultunsealconfigs.vault.io --ignore-not-found=true

        # Create test configuration values
        cat > /tmp/test-values.yaml <<EOF
        image:
          repository: vault-autounseal-operator
          tag: test
          pullPolicy: Never

        operator:
          logLevel: debug

        resources:
          requests:
            cpu: 100m
            memory: 128Mi
          limits:
            cpu: 500m
            memory: 256Mi

        crd:
          create: true
        EOF

        # Create vault configuration secret (delete and recreate if exists)
        kubectl delete secret vault-config --namespace=vault-operator-system --ignore-not-found=true

        if [ "$TEST_SCENARIO" = "multi-vault" ]; then
          kubectl create secret generic vault-config \
            --namespace=vault-operator-system \
            --from-literal=vault-endpoints="http://host.docker.internal:8200,http://host.docker.internal:8201"
        else
          kubectl create secret generic vault-config \
            --namespace=vault-operator-system \
            --from-literal=vault-endpoints="http://host.docker.internal:8200"
        fi

        # Deploy using Helm with upgrade --install to handle existing installations
        echo "🚀 Deploying with Helm (increased timeout for pod startup)..."
        helm upgrade --install vault-autounseal-operator ./helm/vault-autounseal-operator \
          --namespace vault-operator-system \
          --values /tmp/test-values.yaml \
          --wait --timeout=600s \
          --debug || {
            echo "❌ Helm deployment failed, gathering debug info..."
            kubectl get pods -n vault-operator-system -o wide
            kubectl describe pods -l app.kubernetes.io/name=vault-autounseal-operator -n vault-operator-system
            kubectl logs -l app.kubernetes.io/name=vault-autounseal-operator -n vault-operator-system --tail=50 || true
            kubectl get events -n vault-operator-system --sort-by='.lastTimestamp' --field-selector type=Warning
            exit 1
          }

        echo "✅ Operator deployed successfully via Helm"

    - name: Run comprehensive integration tests
      run: |
        echo "🧪 Running comprehensive integration tests for Vault ${{ matrix.vault-version }}"

        # Wait for operator pods to be ready
        echo "⏳ Waiting for operator to be ready..."
        kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=vault-autounseal-operator -n vault-operator-system --timeout=300s

        # Test 1: Verify operator is running and healthy
        echo "📋 Test 1: Operator Health Check"
        kubectl get pods -n vault-operator-system -o wide
        kubectl logs -l app.kubernetes.io/name=vault-autounseal-operator -n vault-operator-system --tail=20

        # Test 2: Check initial Vault status (should be sealed in dev mode)
        echo "🏛️ Test 2: Initial Vault Status Check"
        VAULT_STATUS=$(curl -s http://localhost:8200/v1/sys/seal-status || echo "failed")
        echo "Vault status: $VAULT_STATUS"
        
        # Test 3: Create VaultUnsealConfig CRD resource
        echo "📝 Test 3: Creating VaultUnsealConfig Resource"
        
        if [ "$TEST_SCENARIO" = "multi-vault" ]; then
          cat <<EOF | kubectl apply -f -
        apiVersion: vault.io/v1
        kind: VaultUnsealConfig
        metadata:
          name: test-multi-vault-config
          namespace: default
        spec:
          vaultInstances:
          - name: vault-primary
            endpoint: "http://host.docker.internal:8200"
            unsealKeys:
            - "$(echo -n 'test-key-1' | base64)"
            - "$(echo -n 'test-key-2' | base64)"
            - "$(echo -n 'test-key-3' | base64)"
            threshold: 3
            tlsSkipVerify: true
          - name: vault-secondary
            endpoint: "http://host.docker.internal:8201"
            unsealKeys:
            - "$(echo -n 'test-key-1' | base64)"
            - "$(echo -n 'test-key-2' | base64)"
            - "$(echo -n 'test-key-3' | base64)"
            threshold: 3
            tlsSkipVerify: true
        EOF
        else
          cat <<EOF | kubectl apply -f -
        apiVersion: vault.io/v1
        kind: VaultUnsealConfig
        metadata:
          name: test-single-vault-config
          namespace: default
        spec:
          vaultInstances:
          - name: vault-primary
            endpoint: "http://host.docker.internal:8200"
            unsealKeys:
            - "$(echo -n 'test-key-1' | base64)"
            - "$(echo -n 'test-key-2' | base64)"
            - "$(echo -n 'test-key-3' | base64)"
            threshold: 3
            tlsSkipVerify: true
        EOF
        fi
        
        echo "✅ VaultUnsealConfig resource created"

        # Test 4: Verify CRD resource was created
        echo "🔍 Test 4: Verify CRD Resource"
        kubectl get vaultunsealconfigs -o wide
        kubectl describe vaultunsealconfigs

        # Test 5: Wait for operator to process the resource
        echo "⏳ Test 5: Waiting for operator to process resource..."
        sleep 30

        # Test 6: Check operator logs for processing
        echo "📝 Test 6: Operator Processing Logs"
        kubectl logs -l app.kubernetes.io/name=vault-autounseal-operator -n vault-operator-system --tail=50

        # Test 7: Verify VaultUnsealConfig status is updated
        echo "📊 Test 7: Check Resource Status Updates"
        kubectl get vaultunsealconfigs -o yaml

        # Test 8: Test Vault unsealing (note: dev mode Vault doesn't seal/unseal like production)
        echo "🔓 Test 8: Vault Accessibility Test"
        if [ "$TEST_SCENARIO" = "multi-vault" ]; then
          echo "Testing both Vault instances..."
          curl -s http://localhost:8200/v1/sys/health | jq '.initialized // false' || echo "Primary Vault test failed"
          curl -s http://localhost:8201/v1/sys/health | jq '.initialized // false' || echo "Secondary Vault test failed"
        else
          echo "Testing single Vault instance..."
          curl -s http://localhost:8200/v1/sys/health | jq '.initialized // false' || echo "Vault test failed"
        fi

        # Test 9: Check for any error events
        echo "⚠️ Test 9: Check for Error Events"
        kubectl get events --field-selector type=Warning -o wide

        # Test 10: Final operator health check
        echo "💚 Test 10: Final Health Verification"
        kubectl get pods -n vault-operator-system
        kubectl get vaultunsealconfigs -o wide

        echo "✅ Integration tests completed successfully!"

    - name: Test resource cleanup and recreation
      run: |
        echo "🧹 Testing resource lifecycle management..."
        
        # Delete the VaultUnsealConfig
        kubectl delete vaultunsealconfigs --all
        
        # Wait for cleanup
        sleep 10
        
        # Verify cleanup in logs
        kubectl logs -l app.kubernetes.io/name=vault-autounseal-operator -n vault-operator-system --tail=20
        
        # Recreate resource to test operator resilience
        cat <<EOF | kubectl apply -f -
        apiVersion: vault.io/v1
        kind: VaultUnsealConfig
        metadata:
          name: test-resilience-config
          namespace: default
        spec:
          vaultInstances:
          - name: vault-test
            endpoint: "http://host.docker.internal:8200"
            unsealKeys:
            - "$(echo -n 'test-resilience-key' | base64)"
            threshold: 1
            tlsSkipVerify: true
        EOF
        
        # Wait and verify
        sleep 15
        kubectl get vaultunsealconfigs -o wide
        kubectl logs -l app.kubernetes.io/name=vault-autounseal-operator -n vault-operator-system --tail=10
        
        echo "✅ Resource lifecycle tests completed!"

    - name: Test with production-like Vault (sealed state)
      run: |
        echo "🏭 Testing with production-like sealed Vault..."
        
        # Stop dev mode Vault
        docker stop vault-primary || true
        
        # Start Vault in production mode (sealed by default)
        docker run -d --name vault-prod --cap-add=IPC_LOCK -p 8202:8200 \
          -e VAULT_API_ADDR=http://0.0.0.0:8200 \
          hashicorp/vault:${{ matrix.vault-version }} server -dev=false -config=/tmp/vault.hcl || {
          # If that fails, use a simpler production config
          docker run -d --name vault-prod --cap-add=IPC_LOCK -p 8202:8200 \
            hashicorp/vault:${{ matrix.vault-version }} server -dev=false
        }
        
        # Wait for Vault to start
        sleep 10
        
        # Check sealed status
        echo "🔒 Checking sealed Vault status..."
        curl -s http://localhost:8202/v1/sys/seal-status | jq '.' || echo "Sealed Vault not accessible yet"
        
        # Create VaultUnsealConfig for production Vault
        cat <<EOF | kubectl apply -f -
        apiVersion: vault.io/v1
        kind: VaultUnsealConfig
        metadata:
          name: test-prod-vault-config
          namespace: default
        spec:
          vaultInstances:
          - name: vault-production
            endpoint: "http://host.docker.internal:8202"
            unsealKeys:
            - "$(echo -n 'prod-key-1' | base64)"
            - "$(echo -n 'prod-key-2' | base64)"
            - "$(echo -n 'prod-key-3' | base64)"
            threshold: 3
            tlsSkipVerify: true
        EOF
        
        # Wait for operator to attempt unsealing
        echo "⏳ Waiting for operator to process production Vault..."
        sleep 20
        
        # Check operator logs for unsealing attempts
        echo "📝 Operator logs for production Vault processing:"
        kubectl logs -l app.kubernetes.io/name=vault-autounseal-operator -n vault-operator-system --tail=30
        
        # Check resource status
        kubectl get vaultunsealconfigs test-prod-vault-config -o yaml | grep -A 10 status: || echo "No status found"
        
        # Clean up production Vault
        docker stop vault-prod || true
        docker rm vault-prod || true
        
        echo "✅ Production Vault testing completed!"

    - name: Cleanup
      if: always()
      run: |
        # Uninstall Helm chart
        helm uninstall vault-autounseal-operator -n vault-operator-system || true

        # Delete k3d cluster
        k3d cluster delete vault-test || true

        # Stop Vault containers
        docker rm -f vault-primary vault-secondary vault-prod || true

  helm-chart-tests:
    name: Helm Chart Tests
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Install Helm
      run: |
        curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash

    - name: Lint Helm chart
      run: |
        echo "🔍 Linting Helm chart..."
        helm lint ./helm/vault-autounseal-operator

    - name: Template Helm chart
      run: |
        echo "📝 Templating Helm chart..."
        helm template vault-autounseal-operator ./helm/vault-autounseal-operator > /tmp/template.yaml

    - name: Package Helm chart
      run: |
        echo "📦 Packaging Helm chart..."
        helm package ./helm/vault-autounseal-operator --destination /tmp/
