package vault

import (
	"context"
	"encoding/base64"
	"fmt"
	"testing"
	"time"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
)

func TestVault(t *testing.T) {
	RegisterFailHandler(Fail)
	RunSpecs(t, "Vault Suite")
}

var _ = Describe("VaultClient", func() {
	var client *Client
	var ctx context.Context

	BeforeEach(func() {
		ctx = context.Background()
	})

	Describe("NewClient", func() {
		It("should create a new client with valid HTTP URL", func() {
			var err error
			client, err = NewClient("http://vault.example.com:8200", false, 30*time.Second)
			Expect(err).ToNot(HaveOccurred())
			Expect(client).ToNot(BeNil())
			Expect(client.url).To(Equal("http://vault.example.com:8200"))
			Expect(client.timeout).To(Equal(30 * time.Second))
		})

		It("should create a new client with valid HTTPS URL", func() {
			var err error
			client, err = NewClient("https://vault.example.com:8200", false, 30*time.Second)
			Expect(err).ToNot(HaveOccurred())
			Expect(client).ToNot(BeNil())
			Expect(client.url).To(Equal("https://vault.example.com:8200"))
		})

		It("should create a client with TLS skip verify enabled", func() {
			var err error
			client, err = NewClient("https://vault.example.com:8200", true, 30*time.Second)
			Expect(err).ToNot(HaveOccurred())
			Expect(client).ToNot(BeNil())
		})

		It("should handle different timeout values", func() {
			testCases := []time.Duration{
				1 * time.Second,
				5 * time.Second,
				30 * time.Second,
				2 * time.Minute,
			}

			for _, timeout := range testCases {
				var err error
				client, err = NewClient("http://vault.example.com:8200", false, timeout)
				Expect(err).ToNot(HaveOccurred())
				Expect(client).ToNot(BeNil())
				Expect(client.timeout).To(Equal(timeout))
			}
		})

		It("should handle URLs with different ports", func() {
			testCases := []struct {
				url      string
				expected string
			}{
				{"http://vault:8200", "http://vault:8200"},
				{"https://vault.example.com:443", "https://vault.example.com:443"},
				{"http://localhost:9200", "http://localhost:9200"},
				{"https://127.0.0.1:8200", "https://127.0.0.1:8200"},
			}

			for _, tc := range testCases {
				var err error
				client, err = NewClient(tc.url, false, 30*time.Second)
				Expect(err).ToNot(HaveOccurred(), "Failed for URL: %s", tc.url)
				Expect(client.url).To(Equal(tc.expected))
			}
		})

		It("should handle edge case timeout values", func() {
			// Very short timeout
			var err error
			client, err = NewClient("http://vault.example.com:8200", false, 1*time.Millisecond)
			Expect(err).ToNot(HaveOccurred())
			Expect(client.timeout).To(Equal(1 * time.Millisecond))

			// Zero timeout
			client, err = NewClient("http://vault.example.com:8200", false, 0)
			Expect(err).ToNot(HaveOccurred())
			Expect(client.timeout).To(Equal(30 * time.Second))
		})
	})

	Describe("Input Validation", func() {
		BeforeEach(func() {
			var err error
			client, err = NewClient("http://vault.example.com:8200", false, 30*time.Second)
			Expect(err).ToNot(HaveOccurred())
		})

		Context("Unseal Key Validation", func() {
			It("should return error with empty keys slice", func() {
				_, err := client.Unseal(ctx, []string{}, 1)
				Expect(err).To(HaveOccurred())
				Expect(err.Error()).To(ContainSubstring("no unseal keys provided"))
			})

			It("should return error with nil keys", func() {
				_, err := client.Unseal(ctx, nil, 1)
				Expect(err).To(HaveOccurred())
				Expect(err.Error()).To(ContainSubstring("no unseal keys provided"))
			})

			It("should return error with zero threshold", func() {
				keys := []string{base64.StdEncoding.EncodeToString([]byte("key1"))}
				_, err := client.Unseal(ctx, keys, 0)
				Expect(err).To(HaveOccurred())
				Expect(err.Error()).To(ContainSubstring("threshold must be at least 1"))
			})

			It("should return error with negative threshold", func() {
				keys := []string{base64.StdEncoding.EncodeToString([]byte("key1"))}
				_, err := client.Unseal(ctx, keys, -1)
				Expect(err).To(HaveOccurred())
				Expect(err.Error()).To(ContainSubstring("threshold must be at least 1"))
			})

			It("should return error when threshold exceeds keys", func() {
				keys := []string{base64.StdEncoding.EncodeToString([]byte("key1"))}
				_, err := client.Unseal(ctx, keys, 2)
				Expect(err).To(HaveOccurred())
				Expect(err.Error()).To(ContainSubstring("threshold exceeds number of available keys"))
			})

			It("should return error when threshold exceeds keys by large margin", func() {
				keys := []string{
					base64.StdEncoding.EncodeToString([]byte("key1")),
					base64.StdEncoding.EncodeToString([]byte("key2")),
				}
				_, err := client.Unseal(ctx, keys, 10)
				Expect(err).To(HaveOccurred())
				Expect(err.Error()).To(ContainSubstring("threshold exceeds number of available keys"))
			})
		})

		Context("Base64 Encoding Validation", func() {
			It("should handle invalid base64 characters", func() {
				invalidKeys := []string{
					"invalid-base64!@#",
					"not_base64_at_all",
					"almost=but=not==quite",
					"",
					" ",
					"=",
					"===",
				}

				for _, key := range invalidKeys {
					// Test input validation directly without network calls
					_, err := base64.StdEncoding.DecodeString(key)
					if key != "" && key != " " { // Empty and space might decode as valid base64
						Expect(err).To(HaveOccurred(), "Key should be invalid: %s", key)
					}
				}
			})

			It("should handle valid base64 keys", func() {
				validKeys := []string{
					base64.StdEncoding.EncodeToString([]byte("key1")),
					base64.StdEncoding.EncodeToString([]byte("another-key-value")),
					base64.StdEncoding.EncodeToString([]byte("key with spaces")),
					base64.StdEncoding.EncodeToString([]byte("special!@#$%^&*()characters")),
					"dGVzdA==",     // "test"
					"YWJjZGVmZ2g=", // "abcdefgh"
				}

				for _, key := range validKeys {
					_, err := base64.StdEncoding.DecodeString(key)
					Expect(err).ToNot(HaveOccurred(), "Key should be valid: %s", key)
				}
			})

			It("should handle edge case base64 values", func() {
				edgeCases := []struct {
					input    []byte
					expected string
				}{
					{[]byte(""), ""},
					{[]byte("a"), "YQ=="},
					{[]byte("ab"), "YWI="},
					{[]byte("abc"), "YWJj"},
					{[]byte("1234567890"), "MTIzNDU2Nzg5MA=="},
				}

				for _, tc := range edgeCases {
					encoded := base64.StdEncoding.EncodeToString(tc.input)
					Expect(encoded).To(Equal(tc.expected))

					decoded, err := base64.StdEncoding.DecodeString(encoded)
					Expect(err).ToNot(HaveOccurred())
					Expect(decoded).To(Equal(tc.input))
				}
			})
		})

		Context("Threshold Edge Cases", func() {
			It("should handle threshold equal to number of keys", func() {
				keys := []string{
					base64.StdEncoding.EncodeToString([]byte("key1")),
					base64.StdEncoding.EncodeToString([]byte("key2")),
					base64.StdEncoding.EncodeToString([]byte("key3")),
				}

				// Test with the client's validator through the strategy
				validator := NewDefaultKeyValidator()
				err := validator.ValidateKeys(keys, 3)
				Expect(err).ToNot(HaveOccurred())
			})

			It("should handle single key with threshold 1", func() {
				keys := []string{base64.StdEncoding.EncodeToString([]byte("single-key"))}

				validator := NewDefaultKeyValidator()
				err := validator.ValidateKeys(keys, 1)
				Expect(err).ToNot(HaveOccurred())
			})

			It("should handle many keys with various thresholds", func() {
				// Generate 10 keys
				keys := make([]string, 10)
				for i := 0; i < 10; i++ {
					keys[i] = base64.StdEncoding.EncodeToString([]byte(fmt.Sprintf("key-%d", i+1)))
				}

				validator := NewDefaultKeyValidator()

				// Test various valid thresholds
				for threshold := 1; threshold <= 10; threshold++ {
					err := validator.ValidateKeys(keys, threshold)
					Expect(err).ToNot(HaveOccurred(), "Threshold %d should be valid for %d keys", threshold, len(keys))
				}

				// Test invalid threshold
				err := validator.ValidateKeys(keys, 11)
				Expect(err).To(HaveOccurred())
				Expect(err.Error()).To(ContainSubstring("threshold exceeds number of available keys"))
			})
		})

		Context("Key Content Validation", func() {
			It("should handle various key lengths", func() {
				keyLengths := []int{1, 8, 16, 32, 64, 128, 256, 512}
				validator := NewDefaultKeyValidator()

				for _, length := range keyLengths {
					// Generate key of specified length
					keyBytes := make([]byte, length)
					for i := 0; i < length; i++ {
						keyBytes[i] = byte(i % 256)
					}

					encodedKey := base64.StdEncoding.EncodeToString(keyBytes)
					keys := []string{encodedKey}

					err := validator.ValidateKeys(keys, 1)
					Expect(err).ToNot(HaveOccurred(), "Key length %d should be valid", length)
				}
			})

			It("should handle binary data in keys", func() {
				// Test with various binary patterns
				binaryPatterns := [][]byte{
					{0x00, 0x01, 0x02, 0x03, 0x04, 0x05},
					{0xFF, 0xFE, 0xFD, 0xFC, 0xFB, 0xFA},
					{0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF},
					{0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF},
				}

				validator := NewDefaultKeyValidator()
				for i, pattern := range binaryPatterns {
					encodedKey := base64.StdEncoding.EncodeToString(pattern)
					keys := []string{encodedKey}

					err := validator.ValidateKeys(keys, 1)
					Expect(err).ToNot(HaveOccurred(), "Binary pattern %d should be valid", i)
				}
			})
		})
	})

	Describe("Error Handling and Edge Cases", func() {
		BeforeEach(func() {
			var err error
			client, err = NewClient("http://vault.example.com:8200", false, 30*time.Second)
			Expect(err).ToNot(HaveOccurred())
		})

		Context("Network and Connection Errors", func() {
			It("should handle connection to invalid host", func() {
				invalidClient, err := NewClient("http://invalid-host-that-does-not-exist.local:8200", false, 1*time.Second)
				Expect(err).ToNot(HaveOccurred()) // Client creation should succeed
				Expect(invalidClient).ToNot(BeNil())

				// Network calls should fail
				_, err = invalidClient.IsSealed(ctx)
				Expect(err).To(HaveOccurred())
				Expect(err.Error()).To(ContainSubstring("failed to get seal status"))
			})

			It("should handle connection to unreachable port", func() {
				unreachableClient, err := NewClient("http://127.0.0.1:9999", false, 1*time.Second)
				Expect(err).ToNot(HaveOccurred())
				Expect(unreachableClient).ToNot(BeNil())

				// Network calls should fail
				_, err = unreachableClient.IsSealed(ctx)
				Expect(err).To(HaveOccurred())
				Expect(err.Error()).To(ContainSubstring("failed to get seal status"))
			})

			It("should handle very short timeouts", func() {
				shortTimeoutClient, err := NewClient("http://vault.example.com:8200", false, 1*time.Millisecond)
				Expect(err).ToNot(HaveOccurred())
				Expect(shortTimeoutClient).ToNot(BeNil())

				// Operations should timeout quickly
				_, err = shortTimeoutClient.IsSealed(ctx)
				Expect(err).To(HaveOccurred())
			})
		})

		Context("Context Cancellation", func() {
			It("should handle canceled context", func() {
				cancelledCtx, cancel := context.WithCancel(ctx)
				cancel() // Cancel immediately

				_, err := client.IsSealed(cancelledCtx)
				Expect(err).To(HaveOccurred())
			})

			It("should handle context with deadline", func() {
				deadlineCtx, cancel := context.WithTimeout(ctx, 1*time.Millisecond)
				defer cancel()

				// Wait for context to expire
				time.Sleep(2 * time.Millisecond)

				_, err := client.IsSealed(deadlineCtx)
				Expect(err).To(HaveOccurred())
			})
		})

		Context("Memory Safety", func() {
			It("should clear key data from memory after use", func() {
				// This tests the security feature that clears keys from memory
				testKey := "test-key-that-should-be-cleared"
				encodedKey := base64.StdEncoding.EncodeToString([]byte(testKey))

				// Test the validator directly since client validation is now in the strategy
				validator := NewDefaultKeyValidator()
				keys := []string{encodedKey}
				err := validator.ValidateKeys(keys, 1)
				Expect(err).ToNot(HaveOccurred())
			})
		})

		Context("Concurrent Operations", func() {
			It("should handle concurrent validation calls", func() {
				done := make(chan bool, 10)
				validator := NewDefaultKeyValidator()

				// Start 10 concurrent validation operations
				for i := 0; i < 10; i++ {
					go func(index int) {
						defer func() { done <- true }()

						keys := []string{base64.StdEncoding.EncodeToString([]byte(fmt.Sprintf("key-%d", index)))}
						err := validator.ValidateKeys(keys, 1)
						Expect(err).ToNot(HaveOccurred())
					}(i)
				}

				// Wait for all goroutines to complete
				for i := 0; i < 10; i++ {
					<-done
				}
			})
		})
	})

	Describe("TLS Configuration", func() {
		Context("TLS Skip Verify", func() {
			It("should configure TLS skip verify correctly", func() {
				tlsClient, err := NewClient("https://vault.example.com:8200", true, 30*time.Second)
				Expect(err).ToNot(HaveOccurred())
				Expect(tlsClient).ToNot(BeNil())

				// Verify client was created successfully with TLS skip verify
				Expect(tlsClient.url).To(Equal("https://vault.example.com:8200"))
			})

			It("should handle TLS configuration without skip verify", func() {
				tlsClient, err := NewClient("https://vault.example.com:8200", false, 30*time.Second)
				Expect(err).ToNot(HaveOccurred())
				Expect(tlsClient).ToNot(BeNil())
			})
		})
	})

	Describe("HTTP Client Configuration", func() {
		It("should set proper security headers", func() {
			testClient, err := NewClient("http://vault.example.com:8200", false, 30*time.Second)
			Expect(err).ToNot(HaveOccurred())
			Expect(testClient).ToNot(BeNil())

			// The client should be properly configured with security headers
			// This is mainly testing that client creation doesn't fail
		})

		It("should configure HTTP transport properly", func() {
			testClient, err := NewClient("http://vault.example.com:8200", false, 30*time.Second)
			Expect(err).ToNot(HaveOccurred())
			Expect(testClient).ToNot(BeNil())
			Expect(testClient.timeout).To(Equal(30 * time.Second))
		})
	})
})
